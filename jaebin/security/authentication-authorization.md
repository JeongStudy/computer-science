파일명 예시: `authentication-authorization-overview.md`

---

# 인증(Authentication)과 인가(Authorization)

## 핵심 개념

* 인증(Authentication)
  사용자가 누구인지 확인하는 과정.
  예) 아이디/비밀번호 입력, 휴대폰 인증, 인증서 로그인 등.

* 인가(Authorization)
  인증된 사용자가 어떤 자원과 기능에 접근할 수 있는지 권한을 결정하는 과정.
  예) 일반 유저는 내 정보만 조회, 관리자는 전체 회원 조회 가능 등.

* 관계
  보통 순서는 “인증 → 인가”이며, 인증이 되지 않으면 인가(권한 검사)도 의미가 없다.

---

## 인증 방식 전체 그림

대표적인 인증 방식들을 흐름 기준으로 나누면 다음과 같이 볼 수 있다.

1. 가장 기본: 아이디/비밀번호 로그인
2. 로그인 상태 유지: 세션 기반 인증
3. 서버 상태를 최소화: 토큰 기반 인증(JWT 등)
4. 제3자에게 권한 위임: OAuth 2.0 (소셜 로그인 등)
5. 추가 보안 층: MFA(2차 인증), SSO(싱글 사인온) 등

아래에서 각 방식을 간단히 정리한다.

---

## 1. 아이디/비밀번호 기반 로그인

사용자가 직접 서비스에 계정을 만들고, 아이디/비밀번호로 로그인하는 가장 기본적인 방식이다.

* 특징

  * 구현이 쉽고 가장 많이 사용되는 패턴.
  * 비밀번호는 반드시 단방향 해시(bcrypt, scrypt, Argon2 등) 후 저장.
  * 비밀번호 정책(길이, 특수문자, 재사용 금지 등)과 계정 잠금 정책이 중요하다.

* 한계

  * 비밀번호 유출 위험(피싱, 키로깅, 재사용).
  * 추가 인증 수단(MFA)을 붙이지 않으면 보안이 약한 편이다.

---

## 2. 세션 기반 인증 (Session-based Authentication)

서버가 “로그인 상태”를 서버 메모리나 저장소에 유지하고, 클라이언트는 세션 ID만 쿠키로 들고 다니는 방식이다.

* 기본 흐름

  1. 사용자가 아이디/비밀번호로 로그인 요청.
  2. 서버가 인증에 성공하면 세션 저장소(메모리, Redis 등)에 세션 객체를 만들고, 세션 ID를 생성.
  3. 세션 ID를 쿠키로 내려 보냄(`Set-Cookie`).
  4. 이후 요청마다 브라우저가 쿠키를 자동으로 보내고, 서버는 세션 ID로 세션을 조회해 사용자 정보를 복원.

* 장점

  * 서버에서 세션을 삭제하면 즉시 로그아웃 처리 가능.
  * 세션에 필요한 정보를 자유롭게 저장할 수 있어 유연하다.
  * 쿠키만 안전하게 관리하면 비교적 이해/구성이 쉽다.

* 단점

  * 서버가 세션 상태를 들고 있으므로 서버 확장 시 세션 공유(세션 클러스터링, Redis 등)가 필요.
  * CSRF 공격에 취약할 수 있어 CSRF 방어 전략이 중요하다.

---

## 3. 토큰 기반 인증 (Token-based Authentication, JWT 등)

서버가 “로그인 상태”를 서버 메모리에 들고 있지 않고, 서명된 토큰을 클라이언트에 발급해서 그 토큰을 매 요청마다 보내는 방식이다.

* 기본 개념

  * 토큰: 서명된 문자열(대표적으로 JWT)로, 사용자 정보와 만료 시간 등을 포함.
  * 서버는 토큰을 검증하고 유효하면 요청을 처리한다.
  * 서버는 토큰 내용을 별도 DB 조회 없이 검증만으로 신뢰할 수 있다(서버 비밀키 기반 서명).

* 기본 흐름

  1. 로그인 성공 시 서버가 액세스 토큰(Access Token)을 발급.
  2. 클라이언트는 토큰을 저장(로컬 스토리지, 메모리, 쿠키 등)하고, 이후 `Authorization: Bearer <token>` 헤더에 실어서 요청.
  3. 서버는 토큰 서명을 검증하고, 만료 여부와 클레임을 확인해 사용자와 권한을 판단.

* 장점

  * 서버가 세션 상태를 거의 들고 있지 않아서 수평 확장에 유리.
  * 토큰만 있으면 다른 서비스에서도 같은 인증 정보를 검증할 수 있어 마이크로서비스에 적합.

* 단점

  * 토큰 탈취 시 유효기간 동안 계속 악용될 수 있다. 짧은 만료 시간 + 리프레시 토큰 전략이 필요.
  * 토큰을 임의로 “강제 만료”하기 어렵다. 블랙리스트나 토큰 버전 관리 전략이 필요.
  * 토큰 저장 위치에 따라 XSS/CSRF 등 공격면이 달라진다.

---

## 4. OAuth 2.0 (소셜 로그인, 권한 위임)

OAuth 2.0은 기본적으로 “인가(Authorization)” 프레임워크이다.
사용자가 직접 비밀번호를 서비스에 주지 않고, 구글/카카오 같은 외부 서비스에 “내 정보에 접근해도 좋다”라는 권한만 위임하는 방식이다.

* 등장 배경

  * “구글 계정으로 로그인”, “카카오로 회원가입” 같은 소셜 로그인.
  * 비밀번호를 공유하지 않고, 특정 범위(scope)만 허용하고 싶을 때.

* 주요 역할

  * Resource Owner: 실제 사용자.
  * Client: 우리 서비스(예: 쇼핑몰 서버).
  * Authorization Server: 로그인과 토큰 발급을 담당(예: accounts.google.com).
  * Resource Server: 사용자 정보를 가진 API 서버(예: Google People API).

* 대표 플로우 (Authorization Code Grant, 서버 사이드 웹에 많이 사용)

  1. 사용자가 “구글로 로그인” 버튼 클릭 → 구글 로그인 페이지로 리다이렉트.
  2. 사용자 구글 계정 로그인/동의.
  3. Authorization Server가 우리 서비스의 콜백 URL로 Authorization Code 전달.
  4. 우리 서버가 Authorization Code를 가지고 백엔드에서 액세스 토큰 요청.
  5. 액세스 토큰으로 구글 API를 호출해 프로필 정보를 받아온 뒤, 자체 회원 시스템과 매핑.

* 인증과의 관계

  * 원래 OAuth 2.0은 “인가” 표준이라 “사용자가 누구인지”에 대한 표준은 아니다.
  * 사용자의 식별 정보까지 포함한 “로그인 프로토콜”은 보통 OAuth 2.0 위에 OpenID Connect(OIDC)를 얹어서 구현한다.

---

## 5. 세션 vs 토큰 vs OAuth 2.0 비교 관점

* 세션 기반

  * 전통적인 웹 서비스(SSR, 단일 도메인)에 적합.
  * 서버 상태를 가지므로 세션 저장소 설계가 필요.

* 토큰 기반(JWT 등)

  * API 서버, 모바일 앱, SPA, 마이크로서비스 구조에 적합.
  * stateless에 가까워서 확장에 유리하지만, 토큰 폐기/보안 전략을 따로 설계해야 한다.

* OAuth 2.0

  * 외부 서비스 계정(구글, 카카오 등)을 활용하거나, 제3자 앱이 내 API에 접근할 수 있게 할 때 사용.
  * 자체 인증 시스템 위에 “소셜 로그인” 등으로 덧붙이는 느낌으로 많이 사용된다.

---

## 실무에서 고려할 포인트

* 저장 위치

  * 세션 ID는 보통 HttpOnly 쿠키로 저장해 XSS에 대한 노출을 줄인다.
  * 토큰은 로컬 스토리지, 메모리, 쿠키 중 어디에 둘지에 따라 보안 트레이드오프가 존재한다.

* 만료와 로그아웃

  * 세션은 서버에서 세션을 지우면 즉시 로그아웃 가능.
  * 토큰은 만료 시간과 리프레시 토큰, 블랙리스트, 토큰 버전 필드 등을 조합해서 설계해야 한다.

* CSRF vs XSS

  * 세션/쿠키 기반에서는 CSRF 방어(CSRF 토큰, SameSite 쿠키 설정)가 중요하다.
  * 토큰을 JS 접근 가능한 저장소에 둘 경우 XSS로 탈취될 위험이 크다.

* MFA / SSO

  * 중요한 서비스라면 ID/PW에만 의존하지 말고, SMS/OTP/인증앱 등 MFA를 붙이는 것이 일반적이다.
  * 여러 서비스 간에 한 번 로그인으로 모두 사용하게 하려면 SSO(IdP, SAML/OIDC 등)를 사용한다.

---

## 용어 정리

| 키워드                              | 설명                                                         |
| -------------------------------- | ---------------------------------------------------------- |
| 인증(Authentication)               | 사용자가 누구인지 확인하는 과정                                          |
| 인가(Authorization)                | 인증된 사용자가 어떤 자원과 기능을 사용할 수 있는지 권한을 확인하는 과정                  |
| 세션(Session)                      | 서버 측에 저장되는 로그인 상태 정보. 사용자별로 고유 세션 ID가 매핑된다                 |
| 세션 ID(Session ID)                | 세션을 식별하기 위한 토큰 문자열. 보통 쿠키로 클라이언트에 전달된다                     |
| 세션 기반 인증                         | 서버가 세션 상태를 저장하고, 클라이언트는 세션 ID만 들고 다니는 인증 방식                |
| 토큰(Token)                        | 인증/인가 정보를 담고 서명된 문자열. 서버는 토큰 검증으로 사용자를 식별할 수 있다            |
| JWT(Json Web Token)              | JSON 기반의 토큰 포맷. 헤더, 페이로드, 서명을 포함하며 주로 Bearer 토큰으로 사용된다     |
| 액세스 토큰(Access Token)             | 보호 자원(API)에 접근할 때 사용하는 토큰. 만료 시간이 비교적 짧다                   |
| 리프레시 토큰(Refresh Token)           | 액세스 토큰이 만료되었을 때 새 액세스 토큰을 받기 위한 토큰. 더 긴 만료 시간과 강한 보호가 필요하다 |
| OAuth 2.0                        | 클라이언트가 자원 소유자를 대신해 자원 서버에 접근할 수 있도록 권한을 위임하는 인가 프레임워크      |
| OpenID Connect(OIDC)             | OAuth 2.0 위에 사용자의 인증 정보를 표준화해 “로그인”을 구현할 수 있도록 하는 프로토콜     |
| Resource Owner                   | 실제 자원(데이터)의 소유자, 보통 최종 사용자                                 |
| Client                           | 사용자를 대신해 자원에 접근하는 애플리케이션(우리 서비스 서버 등)                      |
| Authorization Server             | 로그인/동의 처리 후 토큰을 발급하는 서버                                    |
| Resource Server                  | 사용자 데이터(API)를 실제로 제공하는 서버                                  |
| MFA(Multi-Factor Authentication) | 두 가지 이상 인증 수단을 사용하는 인증 방식. 예: 비밀번호 + SMS 코드                |
| SSO(Single Sign-On)              | 한 번 로그인으로 여러 시스템에 동시에 로그인된 효과를 제공하는 방식                     |
| 세션 하이재킹(Session Hijacking)       | 세션 ID를 탈취해 다른 사용자인 것처럼 위장하는 공격                             |
| 토큰 탈취(Token Theft)               | 토큰을 훔쳐 유효기간 동안 권한을 악용하는 공격                                 |

---
